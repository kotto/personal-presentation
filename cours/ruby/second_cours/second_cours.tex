%presentation
\documentclass{beamer}

%impressions
%\documentclass[handout]{beamer}
%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]
%\setbeameroption{notes on second screen}
%\pgfpagelayout{2 on 1}[a4paper, border, shrink=5mm]
% vue sur http://wwwtaketorg/spip/articlephp3?id_article=30...
%\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8x]{inputenc} % Pour pouvoir taper les accents sans faire de combinaison
%\usepackage{arev}
%\usepackage{aeguill}
%mode code
\usepackage{listings}

%mode verbatim
\usepackage{moreverb}

%\usepackage[darktab]{beamerthemesidebar}
%\leftsidebar
%\usetheme{Hannover}
%\usetheme{Warsaw}
%\usetheme{PaloAlto}
\usetheme{JuanLesPins}
%\usetheme{Antibes}
%\usetheme{Shingara}
%\usetheme{Berlin}
%\usetheme{Oxygen}
\usepackage{thumbpdf}
\usepackage{wasysym}
\usepackage{ucs}
\usepackage{pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{verbatim}
\usepackage{color}

\title{D\'ebuter en Ruby}
\author{Cyril Mougel}

\setbeamertemplate{blocks}[rounded]%
[shadow=false]


\lstset{
  breaklines=true
    , language=ruby
    , numbers=left
    , tabsize=2
    , basicstyle=\small\ttfamily
    , keywordstyle=\color{blue}
    , commentstyle=\color{green}
    , stringstyle=\color{red}
    , identifierstyle=\ttfamily
    , columns=fixed
    , showstringspaces=false
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Convention de nommage}
  \begin{block}{Classe en CamelCase}
    Le nom des classes est toujours indiqu\'e en CamelCase.
  \end{block}
  \begin{block}{minuscule et underscor\'e}
    Chaque nom de m\'ethode n'est compos\'e que de nom en minuscule. Les espaces entre les mots est s\'epar\'e par des underscores
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Point d'interrogation}
    Dans le cas de m\'ethode qui renvoye \verb?true? ou \verb?false? la convention est de mettre un point d'interrogation à la fin du nom de m\'ethode
  \end{block}
  \begin{block}{Point d'exclamation}
    On met un point d'exclamation à la fin d'un nom de m\'ethode dans le cas où la m\'ethode a une action directe sur l'objet alors que la m\'ethode sans point d'exclamation renvoi un nouvelle objet. ex: gsub / gsub!
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{require}
  \begin{block}{Ajoute les fichiers}
    Permet de rajouter d'autre fichier ruby à notre fichier actuel. Utilis\'e pour ajouter des librairies.
  \end{block}
  \begin{block}{Avec ou sans extension}
    Pour donner le chemin du fichier à inclure on ajoute le path complet ou non. Dans le cas dun path complet on ajoute l'extension. Par contre on peux ne mettre que le nom du fichier sans extension. Mais ce fichier doit être dans le '\$LOAD\_PATH'
  \end{block}
  \begin{block}{\$LOAD\_PATH}
    Le '\$LOAD\_PATH est une liste de dossier où on peux chercher des fichiers ruby. Si on require un fichier sans extension, on cherchera donc un fichier ruby avec ce nom et l'extension '.rb' dans les dossier sur \$LOAD\_PATH
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{require}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{require.rb}
  \end{beamerboxesrounded}
\end{frame}


\begin{frame}
  \frametitle{if else}
  \begin{block}{Se ferme par un '\verb?end?'}
    La fin des instructions s'indique par le mot cl\'e '\verb?end?'.
  \end{block}
  \begin{block}{elsif}
    Cette instruction permet de faire un autre test si le premier \'echoue
  \end{block}
  \begin{block}{unless}
    A l'inverse de '\verb?if?' test que la condition est fausse. Si elle est fausse l'instruction est execut\'ee.
  \end{block}
  \begin{block}{Avant ou après}
      Le '\verb?if?' peux tout à fait être plac\'e après l'instruction qu'il veux executer en cas de succ\'es
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{if else elsif}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{if_else.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{test unitaire}
  \begin{block}{documentation}
    http://www.ruby-doc.org/core/classes/Test/Unit.html
  \end{block}
  \begin{block}{require 'test/unit'}
    La librairie de test unitaire est dans la librairie standard. Il suffit de la \verb?require? en d\'ebut de fichier
  \end{block}
  \begin{block}{H\'erite de Test::Units::TestCase}
    Toutes classes de Test unitaire doit h\'erit\'er de Test::Units::TestCase. La classe doit aussi finir par Test
  \end{block}
  \begin{block}{nom de m\'ethode commençant par \verb?test\_?}
    Toutes les m\'ethodes commençant par \verb?test\_? seront lanc\'e pour faire des tests. Les test ne commançant pas par ce mot cl\'e ne seront pas ex\'ecut\'e par les tests. Ils ne seront appel\'es que si explicitement fait.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{\verb?assert\_equal?}
    L'assertion de base v\'erifie que les deux arguments sont \'egaux l'un par rapport à l'autre
  \end{block}
  \begin{block}{\verb?assert?}
    Permet de v\'erifier que l'argument donn\'e est \verb?true?
  \end{block}
  \begin{block}{setup}
    La m\'ethode particulier '\verb?setup?' est execut\'e avant chaque test. Elle permet de faire des initialisations de donn\'ees
  \end{block}
  \begin{block}{teardown}
    Cette m\'ethode si elle est d\'efini est execut\'e après chaque test. ELle sert à supprimer des donn\'ees cr\'e\'ees durant les tests
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Test Unitaire}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_1.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Cr\'eation d'une classe}
  \begin{block}{Exercice 1}
  Ecrire une classe qui se nomme Car. Elle doit avoir une m\'ethode d'instance qui
  se nomme 'running?' et qui renvoi true ou false.
\end{block}
\end{frame}

\begin{frame}
  \begin{block}{Exercice 1}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_1.rb}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Exercice 2}
  La classe Car doit avoir une m\'ethode 'run' qui d\'emarre la voiture.
  Une fois la voiture d\'emarrer elle doit donc avoir la m\'ethode running? qui
  renvoi true
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 2}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_2.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \begin{block}{Exercice 3}
  Ajouter une m\'ethode 'stop' qui arrete la voiture de rouler. La m\'ethode running?
  doit donc renvoyer cette fois-ci false
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 3}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_3.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \begin{block}{exercice 4}
  Indiquer un attribut d'instance accessible en \'ecriture qui indique le nombre de
  de fois que la voiture s'est arrêt\'ee.
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 4}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_4.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \begin{block}{Exercice 5}
  Permettre d'ajouter un nombre de d\'emarrage/Arrêt lors de la cr\'eation
  d'un objet 'Car'
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 5}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_5.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \begin{block}{exercice 6}
  Ajouter une m\'ethode de classe 'nb\_car' qui indique le nombre de voiture actuellement en
  service.
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 6}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_6.rb}
  \end{beamerboxesrounded}
\end{frame}


\begin{frame}
  \frametitle{Mise en place d'H\'eritage}
  \begin{block}{Exercice 7}
  Avoir une classe Ford qui h\'erite de Car et ajoute une m\'ethode 'marque' qui renvoi l'information que c'est une Ford
  De même avec une Classe Renault
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 7}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_7.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Mise en place de Mixin}
  \begin{block}{Exercice 8}
  Cr\'eer un module qui permette au class Ford et Renault d'avoir une m\'ethode 'add\_driver'
  qui ajoute des passagers à la voiture et une m\'ethode 'has\_driver?' qui renvoi true si il y a un driver.
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 8}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_8.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Les arguments optionnels}
  \begin{block}{Exercice 9}
  Ajouter une m\'ethode à la classe Car qui permette d'ajouter 1 ou 2 passagers. Cette m\'ethode s'appelera 'passenger'. Le premier argument est le nom du premier passager et le deuxième argument est le nom du deuxième passager.

  Les attributs 'first\_passenger' et 'second\_passenger' sont accessible en lecture
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 9}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_9.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Utilisation du super}
  \begin{block}{Exercice 10}
  Ajouter une m\'ethode run dans la class Ford qui fait exactement ce que fait la classe Car, mais renvoi 'boom' en plus
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 10}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_10.rb}
  \end{beamerboxesrounded}
\end{frame}

\section{Les boucles}

\begin{frame}
  \frametitle{Les boucles}
  \begin{block}{while}
    Le mot cl\'e \verb?while? permet de d\'efinir une boucle. on donne une condition après et on fini le block par le mot cl\'e \verb?end?. Ce bloc est execut\'e tant que la condition est vraie.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{while}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{while.rb}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{until}
    Le mot cl\'e \verb?until? est exactement comme while. La diff\'erence est qu'il est son contraire. L'instruction est donc execut\'e que dans le cas où la condition est fausse.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{until}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{until.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{boucle for}
  \begin{block}{for}
    La boucle \verb?for? en ruby a la même syntaxe que dans les autres langage.
    On utilise le mot cl\'e \verb?for? une variable qui sera initialis\'e à
    chaque it\'eration. Ensuite on utilise le mot cl\'e \verb?in? et on donne
    la liste des toutes les valeurs it\'er\'e
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{for}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{for.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{modification de boucle}
  \begin{block}{next}
    Permet d'aller directement à l'\'element suivant
  \end{block}
  \begin{block}{redo}
    Execute le même code avec la même instance
  \end{block}
  \begin{block}{retry}
    Recommence l'it\'eration depuis le d\'ebut et relance entièrement la boucle
  \end{block}
  \begin{block}{break}
    Interromps l'execution de la boucle et sort de celle-ci
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{modification de boucle}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{break_next.rb}
  \end{block}
\end{frame}

\section{Regexp}

\begin{frame}
  \frametitle{Regexp}
  \begin{block}{Composition d'une regexp}
    On peux faire des tests directement avec les Regexp. La syntaxe de Regexp est la même que celle
    utilis\'e en Perl. On engloble une Regexp directement avec / et /
  \end{block}
  \begin{block}{Test d'une Regexp}
    On peux faire un test directement avec cette Regexp avec l'op\'erateur \verb?=~?

    Le retour est la position du d\'ebut du matching. nil si ne match pas.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Regexp}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{regexp.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Matching Regexp}
  \begin{block}{Extraction de partie de sa Regexp}
    On peux extraire certaine partie de notre Regexp si celle-ci match. On possède les
    variable \$1, \$2, etc...
  \end{block}

  \begin{block}{Tester ses Regexp}
    Je conseille l'utilisation de http://rubular.com pour tester ses Regexp et
    v\'erifier le matching
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Matching Regexp}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{matching_regexp.rb}
  \end{block}
\end{frame}

\end{document}
