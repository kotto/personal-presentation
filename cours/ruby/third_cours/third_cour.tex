%presentation
\documentclass{beamer}

%impressions
%\documentclass[handout]{beamer}
%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]
%\setbeameroption{notes on second screen}
%\pgfpagelayout{2 on 1}[a4paper, border, shrink=5mm]
% vue sur http://wwwtaketorg/spip/articlephp3?id_article=30...
%\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8x]{inputenc} % Pour pouvoir taper les accents sans faire de combinaison
%\usepackage{arev}
%\usepackage{aeguill}
%mode code
\usepackage{listings}

%mode verbatim
\usepackage{moreverb}

%\usepackage[darktab]{beamerthemesidebar}
%\leftsidebar
%\usetheme{Hannover}
%\usetheme{Warsaw}
%\usetheme{PaloAlto}
\usetheme{JuanLesPins}
%\usetheme{Antibes}
%\usetheme{Shingara}
%\usetheme{Berlin}
%\usetheme{Oxygen}
\usepackage{thumbpdf}
\usepackage{wasysym}
\usepackage{ucs}
\usepackage{pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{verbatim}
\usepackage{color}

\title{D\'ebuter en Ruby}
\author{Cyril Mougel}

\setbeamertemplate{blocks}[rounded]%
[shadow=false]


\lstset{
  breaklines=true
    , language=ruby
    , numbers=left
    , tabsize=2
    , basicstyle=\small\ttfamily
    , keywordstyle=\color{blue}
    , commentstyle=\color{green}
    , stringstyle=\color{red}
    , identifierstyle=\ttfamily
    , columns=fixed
    , showstringspaces=false
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Mise en place d'H\'eritage}
  \begin{block}{Exercice 7}
  Avoir une classe Ford qui h\'erite de Car et ajoute une m\'ethode 'marque' qui renvoi l'information que c'est une Ford
  De même avec une Classe Renault
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 7}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_7.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Mise en place de Mixin}
  \begin{block}{Exercice 8}
  Cr\'eer un module qui permette au class Ford et Renault d'avoir une m\'ethode 'add\_driver'
  qui ajoute des passagers à la voiture et une m\'ethode 'has\_driver?' qui renvoi true si il y a un driver.
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 8}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_8.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Les arguments optionnels}
  \begin{block}{Exercice 9}
  Ajouter une m\'ethode à la classe Car qui permette d'ajouter 1 ou 2 passagers. Cette m\'ethode s'appelera 'passenger'. Le premier argument est le nom du premier passager et le deuxième argument est le nom du deuxième passager.

  Les attributs 'first\_passenger' et 'second\_passenger' sont accessible en lecture
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 9}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_9.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Utilisation du super}
  \begin{block}{Exercice 10}
  Ajouter une m\'ethode run dans la class Ford qui fait exactement ce que fait la classe Car, mais renvoi 'boom' en plus
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 10}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_10.rb}
  \end{beamerboxesrounded}
\end{frame}

\section{Les boucles}

\begin{frame}
  \frametitle{Les boucles}
  \begin{block}{while}
    Le mot cl\'e \verb?while? permet de d\'efinir une boucle. on donne une condition après et on fini le block par le mot cl\'e \verb?end?. Ce bloc est execut\'e tant que la condition est vraie.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{while}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{while.rb}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{until}
    Le mot cl\'e \verb?until? est exactement comme while. La diff\'erence est qu'il est son contraire. L'instruction est donc execut\'e que dans le cas où la condition est fausse.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{until}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{until.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{boucle for}
  \begin{block}{for}
    La boucle \verb?for? en ruby a la même syntaxe que dans les autres langage.
    On utilise le mot cl\'e \verb?for? une variable qui sera initialis\'e à
    chaque it\'eration. Ensuite on utilise le mot cl\'e \verb?in? et on donne
    la liste des toutes les valeurs it\'er\'e
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{for}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{for.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{modification de boucle}
  \begin{block}{next}
    Permet d'aller directement à l'\'element suivant
  \end{block}
  \begin{block}{redo}
    Execute le même code avec la même instance
  \end{block}
  \begin{block}{retry}
    Recommence l'it\'eration depuis le d\'ebut et relance entièrement la boucle
  \end{block}
  \begin{block}{break}
    Interromps l'execution de la boucle et sort de celle-ci
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{modification de boucle}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{break_next.rb}
  \end{block}
\end{frame}

\section{Regexp}

\begin{frame}
  \frametitle{Regexp}
  \begin{block}{Composition d'une regexp}
    On peux faire des tests directement avec les Regexp. La syntaxe de Regexp est la même que celle
    utilis\'e en Perl. On engloble une Regexp directement avec / et /
  \end{block}
  \begin{block}{Test d'une Regexp}
    On peux faire un test directement avec cette Regexp avec l'op\'erateur \verb?=~?

    Le retour est la position du d\'ebut du matching. nil si ne match pas.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Regexp}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{regexp.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Matching Regexp}
  \begin{block}{Extraction de partie de sa Regexp}
    On peux extraire certaine partie de notre Regexp si celle-ci match. On possède les
    variable \$1, \$2, etc...
  \end{block}

  \begin{block}{Tester ses Regexp}
    Je conseille l'utilisation de http://rubular.com pour tester ses Regexp et
    v\'erifier le matching
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Matching Regexp}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{matching_regexp.rb}
  \end{block}
\end{frame}


\section{Array}

\begin{frame}
  \frametitle{Array}
  \begin{block}{Liste ordonn\'e}
    Array est un object qui correspond à une liste ordonn\'e d'\'element
  \end{block}
  \begin{block}{Diff\'erente instances possible}
    La liste ne contient pas obligatoirement la même classe. Il peux y avoir des instances de classes diff\'erente.
  \end{block}
  \begin{block}{Accesseur possible par l'index}
    Rien n'oblige à parcourir la liste dans l'ordre. On peux acc\'eder à la liste par son index ou la parcourir dans les deux sens.
  \end{block}
  \begin{block}{index commence à 0}
    L'index d'une liste commence à 0
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Array}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{array.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Quelque m\'ethodes d'Array}
  \begin{block}{Array\#each}
    La m\'ethode Array\#each permet d'it\'erer sur tous les items de la liste.
    Elle est exactement identique à la m\'ethode \verb?for?. La syntaxe est par contre diff\'erente et privil\'egi\'e dans le monde Ruby.
  \end{block}
  \begin{block}{Array\#include?}
    M\'ethode d'instance qui permet de savoir si l'\'el\'ement donn\'e en paramètre est dans la liste. Cela permet d'\'eviter d'it\'erer sur toutes
    la liste pour savoir si l'object est inclus dedans.
  \end{block}
  \begin{block}{Array\#map}
    M\'ethode d'instance qui permet d'executer un block sur tous les \'el\'ements de la liste.
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Array}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{method_array.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Cr\'eer simplement un Array}
  \begin{block}{utiliser \%w}
    On peux utiliser \%w pour d\'efinir une Liste. Avec cette m\'ethode
    chaque \'el\'ement est s\'eparer par un espace.
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Array}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{generate_array.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Assignation d'Array}
  \begin{block}{explosion partiel}
    Si on assigne plusieurs variables à gauche. On n'utilise pas toutes les donn\'ees
    du tableaux. On en utilise qu'autant de variable à assigner
  \end{block}
  \begin{block}{l'\'etoile explose le tableau}
    TODO
    ?????
    L'utilisation d'une \'etoile devant un tableau r\'ealise une explosion de celui-ci.
    On peux ainsi retourner toutes
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Array}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{assignation_array.rb}
  \end{beamerboxesrounded}
\end{frame}


\begin{frame}
  \frametitle{Exercice 11}
  Ecrire une classe Parking. Cette classe peux avoir des voitures qui rentre
  et d'autre qui en sortent. On d\'efini le nombre de voitures maximum que le parking
  peux avoir à l'instanciation et on ne peux donc pas avoir plus de voitures qui entrent.
  Si une voiture doit entrer mais que le quota est pass\'e la voiture n'est pas ajout\'ee au
  parking.
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 11}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{../exercices/test_car_11.rb}
  \end{beamerboxesrounded}
\end{frame}

\section{Ouverture de classe}

\begin{frame}
  \frametitle{Ouverture de classe}
  \begin{block}{Exercice 12}
    Permettre la possibilit\'e de cr\'eer des voitures directement à partir d'un entier comment indiqu\'e dans le test suivant.
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Ouverture de classe}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{../exercices/test_car_12.rb}
  \end{beamerboxesrounded}
\end{frame}


\section{ARGV}

\begin{frame}
  \frametitle{ARGV}
  \begin{block}{c'est une constante}
    ARGV est une constante car commence par une majuscule.
  \end{block}
  \begin{block}{Array}
    ARGV est un Array rempli automatiquement
  \end{block}
  \begin{block}{Tous les arguments de la ligne de commande}
    R\'ecup\'ere tous les arguments donn\'es par la ligne de commande.
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{ARGV}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{argv.rb}
  \end{beamerboxesrounded}
\end{frame}


\section{alias}

\begin{frame}
  \frametitle{alias}
  \begin{block}{Même nom pour une même m\'ethode}
    L'utilisation d'alias dans sa classe permet d'avoir des noms de m\'ethode
    diff\'errente pour la même m\'ethode.
  \end{block}
  \begin{block}{Pas de virgule entre argument}
    Il ne faut pas s\'eparer les noms de m\'ethodes par une virgule.
  \end{block}
  \begin{block}{L'appel alias après que la m\'ethode soit d\'efini}
    Si la m\'ethode n'est pas d\'efini, ca ne peux pas marcher.
  \end{block}
  \begin{block}{Cas dans la classe Array}
    Array\#size est un alias de Array\#length permet d'utiliser la m\'ethode qu'on pr\'ef\'ere.
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{alias}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{alias.rb}
  \end{beamerboxesrounded}
\end{frame}

\section{argument *args}

\begin{frame}
  \frametitle{cas de *args}
  \begin{block}{r\'ecupère tous les arguments}
    Avec cet argument permet d'avoir une m\'ethode qui prend
    autant d'argument possible. Le tout est assign\'e dans
    la variable args qui est dans ce cas un Array
  \end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{alias}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{etoile_args.rb}
  \end{beamerboxesrounded}
\end{frame}

\section{Rendre des m\'ethodes protected/private}
%% faire alias running running?
\section{Hash}
\section{Range}
\section{Exception}
\section{Les block}
\section{Les Proc/lambda}
\section{IO/Files}
\section{ruby-debug}
\section{metaprogrammation}
\section{thread}
\section{rdoc/ri}
\section{format ternaire ? :}

\end{document}
