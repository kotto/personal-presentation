%presentation
\documentclass{beamer}

%impressions
%\documentclass[handout]{beamer}
%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]
%\setbeameroption{notes on second screen}
%\pgfpagelayout{2 on 1}[a4paper, border, shrink=5mm]
% vue sur http://wwwtaketorg/spip/articlephp3?id_article=30...
%\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[utf8x]{inputenc} % Pour pouvoir taper les accents sans faire de combinaison
%\usepackage{arev}
%\usepackage{aeguill}
%mode code
\usepackage{listings}

%mode verbatim
\usepackage{moreverb}

%\usepackage[darktab]{beamerthemesidebar}
%\leftsidebar
%\usetheme{Hannover}
%\usetheme{Warsaw}
%\usetheme{PaloAlto}
\usetheme{JuanLesPins}
%\usetheme{Antibes}
%\usetheme{Shingara}
%\usetheme{Berlin}
%\usetheme{Oxygen}
\usepackage{thumbpdf}
\usepackage{wasysym}
\usepackage{ucs}
\usepackage{pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{verbatim}
\usepackage{color}

\title{Troisième cours}
\author{Cyril Mougel}

\setbeamertemplate{blocks}[rounded]%
[shadow=false]


\lstset{
  breaklines=true
    , language=ruby
    , numbers=left
    , tabsize=2
    , basicstyle=\small\ttfamily
    , keywordstyle=\color{blue}
    , commentstyle=\color{green}
    , stringstyle=\color{red}
    , identifierstyle=\ttfamily
    , columns=fixed
    , showstringspaces=false
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Mise en place d'H\'eritage}
  \begin{block}{Exercice 7}
  Avoir une classe Ford qui h\'erite de Car et ajoute une m\'ethode 'marque' qui renvoi l'information que c'est une Ford
  De même avec une Classe Renault
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 7}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_7.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Mise en place de Mixin}
  \begin{block}{Exercice 8}
  Cr\'eer un module qui permette au class Ford et Renault d'avoir une m\'ethode 'add\_driver'
  qui ajoute des passagers à la voiture et une m\'ethode 'has\_driver?' qui renvoi true si il y a un driver.
\end{block}
\end{frame}
\begin{frame}
  \begin{beamerboxesrounded}{Exercice 8}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_8.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Les arguments optionnels}
  \begin{block}{Exercice 9}
  Ajouter une m\'ethode à la classe Car qui permette d'ajouter 1 ou 2 passagers. Cette m\'ethode s'appelera 'passenger'. Le premier argument est le nom du premier passager et le deuxième argument est le nom du deuxième passager.

  Les attributs 'first\_passenger' et 'second\_passenger' sont accessible en lecture
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 9}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_9.rb}
  \end{beamerboxesrounded}
\end{frame}

\begin{frame}
  \frametitle{Utilisation du super}
  \begin{block}{Exercice 10}
  Ajouter une m\'ethode run dans la class Ford qui fait exactement ce que fait la classe Car, mais renvoi 'boom' en plus
\end{block}
\end{frame}

\begin{frame}
  \begin{beamerboxesrounded}{Exercice 10}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{test_car_10.rb}
  \end{beamerboxesrounded}
\end{frame}

\section{Les boucles}

\begin{frame}
  \frametitle{Les boucles}
  \begin{block}{while}
    Le mot cl\'e \verb?while? permet de d\'efinir une boucle. on donne une condition après et on fini le block par le mot cl\'e \verb?end?. Ce bloc est execut\'e tant que la condition est vraie.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{while}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{while.rb}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{until}
    Le mot cl\'e \verb?until? est exactement comme while. La diff\'erence est qu'il est son contraire. L'instruction est donc execut\'e que dans le cas où la condition est fausse.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{until}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{until.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{boucle for}
  \begin{block}{for}
    La boucle \verb?for? en ruby a la même syntaxe que dans les autres langage.
    On utilise le mot cl\'e \verb?for? une variable qui sera initialis\'e à
    chaque it\'eration. Ensuite on utilise le mot cl\'e \verb?in? et on donne
    la liste des toutes les valeurs it\'er\'e
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{for}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{for.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{modification de boucle}
  \begin{block}{next}
    Permet d'aller directement à l'\'element suivant
  \end{block}
  \begin{block}{redo}
    Execute le même code avec la même instance
  \end{block}
  \begin{block}{retry}
    Recommence l'it\'eration depuis le d\'ebut et relance entièrement la boucle
  \end{block}
  \begin{block}{break}
    Interromps l'execution de la boucle et sort de celle-ci
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{modification de boucle}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{break_next.rb}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Redo retru}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{redo_retry.rb}
  \end{block}
\end{frame}

\section{Regexp}

\begin{frame}
  \frametitle{Regexp}
  \begin{block}{Composition d'une regexp}
    On peux faire des tests directement avec les Regexp. La syntaxe de Regexp est la même que celle
    utilis\'e en Perl. On engloble une Regexp directement avec / et /
  \end{block}
  \begin{block}{Test d'une Regexp}
    On peux faire un test directement avec cette Regexp avec l'op\'erateur \verb?=~?

    Le retour est la position du d\'ebut du matching. nil si ne match pas.
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Regexp}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{regexp.rb}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Matching Regexp}
  \begin{block}{Extraction de partie de sa Regexp}
    On peux extraire certaine partie de notre Regexp si celle-ci match. On possède les
    variable \$1, \$2, etc...
  \end{block}

  \begin{block}{Tester ses Regexp}
    Je conseille l'utilisation de http://rubular.com pour tester ses Regexp et
    v\'erifier le matching
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Matching Regexp}
    \lstinputlisting[numbers=none,basicstyle=\tiny]{matching_regexp.rb}
  \end{block}
\end{frame}

\end{document}
